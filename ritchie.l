%{
/* need this for the call to atoi(), atof() below */
#include <math.h>
#include <string.h>
#include "ObjectTree.h"
#include "ritchie.tab.h" /* Generated by bison. */
#include "ritc.h"
#include "error.h"

#define INSERT_BUFF_LEN 1024
#define INDENT_STACK_MAX 512

int g_current_line_indent = 0;
int g_indent_levels[INDENT_STACK_MAX];
int g_indent_levels_index = -1;
int g_is_fake_outdent_symbol = 0;

int  stack_top() { return  g_indent_levels[g_indent_levels_index]; }
int  stack_pop() { return  g_indent_levels[g_indent_levels_index--]; }
void stack_push(int val) { g_indent_levels[++g_indent_levels_index] = val; }
extern int g_lineNum;
extern int g_lineCol;

#define YY_USER_INIT { \
    stack_push(0); \
    BEGIN(initial); \
}

//#define YY_DECL extern int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, yyscan_t scanner )


int yycolumn = 1;
void set_yycolumn(int val) {
    yycolumn = val;
    g_lineCol = yycolumn; //first column
    //yylloc.last_column = yycolumn + yyleng - 1;
}

#define YY_USER_ACTION { \
    g_lineNum = yylineno; \
    set_yycolumn(yycolumn);\
    yycolumn += yyleng; \
}

char* handleCodeInsert(void);

%}

%option yylineno
%option noyywrap

%x initial
%x indent
%s normal

%option bison-bridge bison-locations

alphabetic    [a-zA-Z]
numeral       [0-9]
alphanumeric  {alphabetic}|{numeral}
integer       {numeral}+
float         {numeral}+"."{numeral}*
string        \"(\\.|[^"])*\"
identifier    {alphabetic}{alphanumeric}*
comment       \/\/.*

funcDec       ":"
paramComma    ","
classDec      "::"
classCtor     ":::"
conditionLink "?"
selfIdent     "$"

mathOp        "+"|"-"|"*"|"/"|"^^"
assignment    "="
return        "->"

mathAssign    "+="|"-="|"*="|"/="
comparison    "<"|">"|"<="|">="|"=="|"!="
ternary       "<>"
bitwiseOp     "&"|"^"|"|"|"~"|">>"|"<<"
booleanOp     "||"|"&&"

%%
        int indent_caller = normal;

<*>\n { set_yycolumn(0); yylineno--; REJECT; }
<initial>.  { set_yycolumn(yycolumn-1); indent_caller = normal; yyless(0); BEGIN(indent); }
<initial>\n { indent_caller = normal; yyless(0); BEGIN(indent); return ENDOFLINE; }

<indent>" "     { g_current_line_indent++; }
<indent>\t      { g_current_line_indent++; }
<indent>\n      { g_current_line_indent = 0; /* ignoring blank line */ }
<indent><<EOF>> {
                    // When encountering the end of file, we want to emit an
                    // outdent for all indents currently left.
                    if(stack_top() != 0) {
                        stack_pop();

                        // See the same code below (<indent>.) for a rationale.
                        if(g_current_line_indent != stack_top()) {
                            size_t i;
                            unput('\n');
                            for(i = 0 ; i < stack_top() ; ++i) {
                                unput(' ');
                            }
                        } else {
                            BEGIN(indent_caller);
                        }

                        printf("lexer: EOF OUTDENT\n");
                        decPrev(); //for tracking last-statement.
                        return UNINDENT;
                    } else {
                        yyterminate();
                    }
                }

<indent>.       {
                    if(!g_is_fake_outdent_symbol) {
                        unput(*yytext);
                    }
                    g_is_fake_outdent_symbol = 0;
                    // -2: -1 for putting it back and -1 for ending at the last space.
                    set_yycolumn(yycolumn-1);

                    // Indentation level has increased. It can only ever
                    // increase by one level at a time. Remember how many
                    // spaces this level has and emit an indentation token.
                    if(g_current_line_indent > stack_top()) {
                        printf("lexer: INDENT\n");
                        stack_push(g_current_line_indent);
                        BEGIN(indent_caller);
                        incPrev(); //for tracking last-statement.
                        return INDENT;
                    } else if(g_current_line_indent < stack_top()) {
                        printf("lexer: OUTDENT\n");
                        // Outdenting is the most difficult, as we might need to
                        // outdent multiple times at once, but flex doesn't allow
                        // emitting multiple tokens at once! So we fake this by
                        // 'unput'ting fake lines which will give us the next
                        // outdent.
                        stack_pop();

                        if(g_current_line_indent != stack_top()) {
                            size_t i;
                            // Unput the rest of the current line, including the newline.
                            // We want to keep it untouched.
                            for(i = 0 ; i < g_current_line_indent ; ++i) {
                                unput(' ');
                            }
                            unput('\n');
                            // Now, insert a fake character indented just so
                            // that we get a correct outdent the next time.
                            unput('.');
                            // Though we need to remember that it's a fake one
                            // so we can ignore the symbol.
                            g_is_fake_outdent_symbol = 1;
                            for(i = 0 ; i < stack_top() ; ++i) {
                                unput(' ');
                            }
                            unput('\n');
                        } else {
                            BEGIN(indent_caller);
                        }
                        decPrev(); //for tracking last-statement.
                        return UNINDENT;
                    } else {
                        // No change in indentation, not much to do here...
                        BEGIN(indent_caller);
                    }
                }

<normal>\n    { printf("EOL\n");
                g_current_line_indent = 0;
                indent_caller = YY_START;
                BEGIN(indent);
                return ENDOFLINE; }

     [/][*][^*]*[*]+([^*/][^*]*[*]+)*[/]       { /* DO NOTHING */ }
     [/][*]                                    { criticalError(ERROR_ParseError, "unterminated comment\n"); }
     "#"			  {yylval -> sval =  handleCodeInsert(); return CODE_INSERT; }
<normal>{comment}     { printf("lexer: comment (ignored)\n"); /* do not forward comments at this time.*/ } 
<normal>{string}      { printf("lexer: string\n"); yylval->sval = strdup(yytext); return STRING; }
<normal>{integer}     { printf("lexer: int\n");    yylval->ival = atoi(yytext);   return INT; }
<normal>{float}       { printf("lexer: float\n");  yylval->fval = atof(yytext);   return FLOAT; }
<normal>{mathOp}      { printf("lexer: mathOp\n"); yylval->sval = strdup(yytext); return MATH_OP; }
<normal>{identifier}  { yylval->sval = strdup(yytext);
                        Object* exists = findByName(yytext);
                        if (!exists || exists->type == Variable) {
                          printf("lexer: identifier\n");
                          return IDENT;
                        } else if (exists->type == Function || exists->type == Constructor) {
                          printf("lexer: verb\n");
                          return VERB;
                        } else if (exists->type == Type) {
                          printf("lexer: type\n");
                          return TYPE;
                        } else {
                          printf("lexer: unidentified identifier\n");
                          return IDENT;
                        }
                      }


<normal>{assignment}    { printf("lexer: assignment\n"); yylval->sval = strdup(yytext); return ASSIGNMENT; }
<normal>{conditionLink} { printf("lexer: CondLink\n");   yylval->sval = strdup(yytext); return CONDITIONLINK; }

<normal>{paramComma}    { printf("lexer: ParamComma\n"); yylval->sval = strdup(yytext); return PARAMCOMMA; }
<normal>{funcDec}       { printf("lexer: FuncDec\n");    yylval->sval = strdup(yytext); return FUNCDEC; }
<normal>{classDec}      { printf("lexer: ClassDec\n");   yylval->sval = strdup(yytext); return CLASSDEC; }
<normal>{classCtor}     { printf("lexer: CtorDec\n");    yylval->sval = strdup(yytext); return CTORDEC; }
<normal>{return}        { printf("lexer: Return\n");     yylval->sval = strdup(yytext); return RETURN; }
<normal>{selfIdent}     { printf("lexer: selfIdent\n");  yylval->sval = strdup(yytext); return SELFIDENT; }

<normal>{booleanOp}     { printf("lexer: bitwiseOp\n");  yylval->sval = strdup(yytext); return BOOLEANOP;  }
<normal>{comparison}    { printf("lexer: comparator\n"); yylval->sval = strdup(yytext); return COMPARISON; }
<normal>{ternary}       { printf("lexer: ternary\n");                                   return TERNARY; }
<normal>{mathAssign}    { printf("lexer: MathAssign\n"); yylval->sval = strdup(yytext); return MATHASSIGN; }

<normal><<EOF>>       { return ENDOFFILE; }
<normal>[ \t]+        { g_lineCol += yyleng; } /* eat up whitespace */
<normal>"("           { printf("lexer: (\n"); return LPAREN; }
<normal>")"           { printf("lexer: )\n"); return RPAREN; }
<normal>.             { printf("Unknown symbol encountered: '%s'\n", yytext); }

%%

char* handleCodeInsert(void) {
	 printf("lexer: code insert\n");
	 int c;
	 int index  = 0;
	 char * ci = (char*)malloc(INSERT_BUFF_LEN);
	 while ( c = input()) {
	 	if ( c != '#' && index < INSERT_BUFF_LEN ) {
	 		ci[index++] = c;
	 	}else if ( c == '#' ) {
	 		return ci;
	 	}
	 	if ( c == EOF ) {
		     criticalError(ERROR_ParseError, "unterminated code insert\n");
		     return 0;
		 }
	 }
}


